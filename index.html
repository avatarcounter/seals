// 1. Force-register the service worker immediately
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./coi-serviceworker.js').then(() => {
        console.log("Security Layer Active");
    });
}

let ffmpegInstance = null;

// 2. Function to inject the script only when needed
function loadFFmpegScript() {
    return new Promise((resolve, reject) => {
        if (window.FFmpeg) return resolve();
        const script = document.createElement('script');
        script.src = "https://cdnjs.cloudflare.com";
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
    });
}

async function processVideo() {
    const status = document.getElementById('status');
    const btn = document.getElementById('renderBtn');
    btn.disabled = true;

    try {
        status.innerText = "Connecting to CDN...";
        await loadFFmpegScript(); // Dynamically pull the library

        if (!ffmpegInstance) {
            status.innerText = "Loading FFmpeg Engine...";
            ffmpegInstance = FFmpeg.createFFmpeg({ 
                log: true,
                corePath: 'https://cdnjs.cloudflare.com'
            });
            await ffmpegInstance.load();
        }

        const ffmpeg = ffmpegInstance;
        const mode = document.getElementById('mode').value;
        let images = [];

        if (mode === 'wikimedia') {
            status.innerText = "Searching Wikimedia...";
            images = await fetchWikiImages(document.getElementById('topic').value, document.getElementById('limit').value);
        } else {
            const files = document.getElementById('localFiles').files;
            for (let f of files) images.push(URL.createObjectURL(f));
        }

        if (images.length === 0) throw new Error("No images found.");

        status.innerText = "Writing Files...";
        for (let i = 0; i < images.length; i++) {
            const data = await FFmpeg.fetchFile(images[i]);
            ffmpeg.FS('writeFile', `img${i}.jpg`, data);
        }

        const musicInput = document.getElementById('bgMusic').files[0];
        if (musicInput) {
            ffmpeg.FS('writeFile', 'audio.mp3', await FFmpeg.fetchFile(musicInput));
        }

        status.innerText = "Rendering (Wait)...";
        await ffmpeg.run('-framerate', '1/3', '-i', 'img%d.jpg', '-c:v', 'libx264', '-pix_fmt', 'yuv420p', '-vf', 'scale=1280:720:force_original_aspect_ratio=decrease,pad=1280:720:(ow-iw)/2:(oh-ih)/2', 'out.mp4');

        let finalFile = 'out.mp4';
        if (musicInput) {
            status.innerText = "Mixing Audio...";
            await ffmpeg.run('-i', 'out.mp4', '-i', 'audio.mp3', '-c:v', 'copy', '-c:a', 'aac', '-map', '0:v:0', '-map', '1:a:0', '-shortest', 'final.mp4');
            finalFile = 'final.mp4';
        }

        const data = ffmpeg.FS('readFile', finalFile);
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([data.buffer], { type: 'video/mp4' }));
        a.download = 'video.mp4';
        a.click();
        status.innerText = "Success!";
    } catch (e) {
        status.innerText = "Error: " + e.message;
        console.error(e);
    } finally {
        btn.disabled = false;
    }
}

async function fetchWikiImages(topic, limit) {
    const url = `https://commons.wikimedia.org{encodeURIComponent(topic)}&gsrnamespace=6&gsrlimit=${limit}&prop=imageinfo&iiprop=url&format=json&origin=*`;
    const res = await fetch(url);
    const data = await res.json();
    if (!data.query) return [];
    return Object.values(data.query.pages).map(p => p.imageinfo[0].url).filter(url => url.match(/\.(jpg|jpeg|png)$/i));
}
